{"version":3,"sources":["../src/index.ts","../src/lib/utils/constants.ts","../src/lib/CDN.ts","../src/lib/errors/DiscordAPIError.ts","../src/lib/errors/HTTPError.ts","../src/lib/errors/RateLimitError.ts","../src/lib/RequestManager.ts","../src/lib/handlers/SequentialHandler.ts","../src/lib/utils/utils.ts","../src/lib/REST.ts"],"sourcesContent":["export * from './lib/CDN';\nexport * from './lib/errors/DiscordAPIError';\nexport * from './lib/errors/HTTPError';\nexport * from './lib/errors/RateLimitError';\nexport * from './lib/RequestManager';\nexport * from './lib/REST';\nexport * from './lib/utils/constants';\nexport { makeURLSearchParams, parseResponse } from './lib/utils/utils';\n","import { APIVersion } from 'discord-api-types/v10';\nimport { getGlobalDispatcher } from 'undici';\nimport type { RESTOptions } from '../REST';\n// eslint-disable-next-line @typescript-eslint/no-var-requires, @typescript-eslint/no-require-imports, @typescript-eslint/no-unsafe-assignment\nconst Package = require('../../../package.json');\n\n// eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-unsafe-member-access\nexport const DefaultUserAgent = `DiscordBot (${Package.homepage}, ${Package.version})`;\n\nexport const DefaultRestOptions: Required<RESTOptions> = {\n\tget agent() {\n\t\treturn getGlobalDispatcher();\n\t},\n\tapi: 'https://discord.com/api',\n\tauthPrefix: 'Bot',\n\tcdn: 'https://cdn.discordapp.com',\n\theaders: {},\n\tinvalidRequestWarningInterval: 0,\n\tglobalRequestsPerSecond: 50,\n\toffset: 50,\n\trejectOnRateLimit: null,\n\tretries: 3,\n\ttimeout: 15_000,\n\tuserAgentAppendix: `Node.js ${process.version}`,\n\tversion: APIVersion,\n\thashSweepInterval: 14_400_000, // 4 Hours\n\thashLifetime: 86_400_000, // 24 Hours\n\thandlerSweepInterval: 3_600_000, // 1 Hour\n};\n\n/**\n * The events that the REST manager emits\n */\nexport const enum RESTEvents {\n\tDebug = 'restDebug',\n\tInvalidRequestWarning = 'invalidRequestWarning',\n\tRateLimited = 'rateLimited',\n\tResponse = 'response',\n\tHashSweep = 'hashSweep',\n\tHandlerSweep = 'handlerSweep',\n}\n\nexport const ALLOWED_EXTENSIONS = ['webp', 'png', 'jpg', 'jpeg', 'gif'] as const;\nexport const ALLOWED_STICKER_EXTENSIONS = ['png', 'json'] as const;\nexport const ALLOWED_SIZES = [16, 32, 64, 128, 256, 512, 1024, 2048, 4096] as const;\n\nexport type ImageExtension = typeof ALLOWED_EXTENSIONS[number];\nexport type StickerExtension = typeof ALLOWED_STICKER_EXTENSIONS[number];\nexport type ImageSize = typeof ALLOWED_SIZES[number];\n","import {\n\tALLOWED_EXTENSIONS,\n\tALLOWED_SIZES,\n\tALLOWED_STICKER_EXTENSIONS,\n\tDefaultRestOptions,\n\tImageExtension,\n\tImageSize,\n\tStickerExtension,\n} from './utils/constants';\n\n/**\n * The options used for image URLs\n */\nexport interface BaseImageURLOptions {\n\t/**\n\t * The extension to use for the image URL\n\t * @default 'webp'\n\t */\n\textension?: ImageExtension;\n\t/**\n\t * The size specified in the image URL\n\t */\n\tsize?: ImageSize;\n}\n\n/**\n * The options used for image URLs with animated content\n */\nexport interface ImageURLOptions extends BaseImageURLOptions {\n\t/**\n\t * Whether or not to prefer the static version of an image asset.\n\t */\n\tforceStatic?: boolean;\n}\n\n/**\n * The options to use when making a CDN URL\n */\nexport interface MakeURLOptions {\n\t/**\n\t * The extension to use for the image URL\n\t * @default 'webp'\n\t */\n\textension?: string | undefined;\n\t/**\n\t * The size specified in the image URL\n\t */\n\tsize?: ImageSize;\n\t/**\n\t * The allowed extensions that can be used\n\t */\n\tallowedExtensions?: ReadonlyArray<string>;\n}\n\n/**\n * The CDN link builder\n */\nexport class CDN {\n\tpublic constructor(private readonly base: string = DefaultRestOptions.cdn) {}\n\n\t/**\n\t * Generates an app asset URL for a client's asset.\n\t * @param clientId The client id that has the asset\n\t * @param assetHash The hash provided by Discord for this asset\n\t * @param options Optional options for the asset\n\t */\n\tpublic appAsset(clientId: string, assetHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/app-assets/${clientId}/${assetHash}`, options);\n\t}\n\n\t/**\n\t * Generates an app icon URL for a client's icon.\n\t * @param clientId The client id that has the icon\n\t * @param iconHash The hash provided by Discord for this icon\n\t * @param options Optional options for the icon\n\t */\n\tpublic appIcon(clientId: string, iconHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/app-icons/${clientId}/${iconHash}`, options);\n\t}\n\n\t/**\n\t * Generates an avatar URL, e.g. for a user or a webhook.\n\t * @param id The id that has the icon\n\t * @param avatarHash The hash provided by Discord for this avatar\n\t * @param options Optional options for the avatar\n\t */\n\tpublic avatar(id: string, avatarHash: string, options?: Readonly<ImageURLOptions>): string {\n\t\treturn this.dynamicMakeURL(`/avatars/${id}/${avatarHash}`, avatarHash, options);\n\t}\n\n\t/**\n\t * Generates a banner URL, e.g. for a user or a guild.\n\t * @param id The id that has the banner splash\n\t * @param bannerHash The hash provided by Discord for this banner\n\t * @param options Optional options for the banner\n\t */\n\tpublic banner(id: string, bannerHash: string, options?: Readonly<ImageURLOptions>): string {\n\t\treturn this.dynamicMakeURL(`/banners/${id}/${bannerHash}`, bannerHash, options);\n\t}\n\n\t/**\n\t * Generates an icon URL for a channel, e.g. a group DM.\n\t * @param channelId The channel id that has the icon\n\t * @param iconHash The hash provided by Discord for this channel\n\t * @param options Optional options for the icon\n\t */\n\tpublic channelIcon(channelId: string, iconHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/channel-icons/${channelId}/${iconHash}`, options);\n\t}\n\n\t/**\n\t * Generates the default avatar URL for a discriminator.\n\t * @param discriminator The discriminator modulo 5\n\t */\n\tpublic defaultAvatar(discriminator: number): string {\n\t\treturn this.makeURL(`/embed/avatars/${discriminator}`, { extension: 'png' });\n\t}\n\n\t/**\n\t * Generates a discovery splash URL for a guild's discovery splash.\n\t * @param guildId The guild id that has the discovery splash\n\t * @param splashHash The hash provided by Discord for this splash\n\t * @param options Optional options for the splash\n\t */\n\tpublic discoverySplash(guildId: string, splashHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/discovery-splashes/${guildId}/${splashHash}`, options);\n\t}\n\n\t/**\n\t * Generates an emoji's URL for an emoji.\n\t * @param emojiId The emoji id\n\t * @param extension The extension of the emoji\n\t */\n\tpublic emoji(emojiId: string, extension?: ImageExtension): string {\n\t\treturn this.makeURL(`/emojis/${emojiId}`, { extension });\n\t}\n\n\t/**\n\t * Generates a guild member avatar URL.\n\t * @param guildId The id of the guild\n\t * @param userId The id of the user\n\t * @param avatarHash The hash provided by Discord for this avatar\n\t * @param options Optional options for the avatar\n\t */\n\tpublic guildMemberAvatar(\n\t\tguildId: string,\n\t\tuserId: string,\n\t\tavatarHash: string,\n\t\toptions?: Readonly<ImageURLOptions>,\n\t): string {\n\t\treturn this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/avatars/${avatarHash}`, avatarHash, options);\n\t}\n\n\t/**\n\t * Generates an icon URL, e.g. for a guild.\n\t * @param id The id that has the icon splash\n\t * @param iconHash The hash provided by Discord for this icon\n\t * @param options Optional options for the icon\n\t */\n\tpublic icon(id: string, iconHash: string, options?: Readonly<ImageURLOptions>): string {\n\t\treturn this.dynamicMakeURL(`/icons/${id}/${iconHash}`, iconHash, options);\n\t}\n\n\t/**\n\t * Generates a URL for the icon of a role\n\t * @param roleId The id of the role that has the icon\n\t * @param roleIconHash The hash provided by Discord for this role icon\n\t * @param options Optional options for the role icon\n\t */\n\tpublic roleIcon(roleId: string, roleIconHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/role-icons/${roleId}/${roleIconHash}`, options);\n\t}\n\n\t/**\n\t * Generates a guild invite splash URL for a guild's invite splash.\n\t * @param guildId The guild id that has the invite splash\n\t * @param splashHash The hash provided by Discord for this splash\n\t * @param options Optional options for the splash\n\t */\n\tpublic splash(guildId: string, splashHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/splashes/${guildId}/${splashHash}`, options);\n\t}\n\n\t/**\n\t * Generates a sticker URL.\n\t * @param stickerId The sticker id\n\t * @param extension The extension of the sticker\n\t */\n\tpublic sticker(stickerId: string, extension?: StickerExtension): string {\n\t\treturn this.makeURL(`/stickers/${stickerId}`, {\n\t\t\tallowedExtensions: ALLOWED_STICKER_EXTENSIONS,\n\t\t\textension: extension ?? 'png', // Stickers cannot have a `.webp` extension, so we default to a `.png`\n\t\t});\n\t}\n\n\t/**\n\t * Generates a sticker pack banner URL.\n\t * @param bannerId The banner id\n\t * @param options Optional options for the banner\n\t */\n\tpublic stickerPackBanner(bannerId: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/app-assets/710982414301790216/store/${bannerId}`, options);\n\t}\n\n\t/**\n\t * Generates a team icon URL for a team's icon.\n\t * @param teamId The team id that has the icon\n\t * @param iconHash The hash provided by Discord for this icon\n\t * @param options Optional options for the icon\n\t */\n\tpublic teamIcon(teamId: string, iconHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/team-icons/${teamId}/${iconHash}`, options);\n\t}\n\n\t/**\n\t * Generates a cover image for a guild scheduled event.\n\t * @param scheduledEventId The scheduled event id\n\t * @param coverHash The hash provided by discord for this cover image\n\t * @param options Optional options for the cover image\n\t */\n\tpublic guildScheduledEventCover(\n\t\tscheduledEventId: string,\n\t\tcoverHash: string,\n\t\toptions?: Readonly<BaseImageURLOptions>,\n\t): string {\n\t\treturn this.makeURL(`/guild-events/${scheduledEventId}/${coverHash}`, options);\n\t}\n\n\t/**\n\t * Constructs the URL for the resource, checking whether or not `hash` starts with `a_` if `dynamic` is set to `true`.\n\t * @param route The base cdn route\n\t * @param hash The hash provided by Discord for this icon\n\t * @param options Optional options for the link\n\t */\n\tprivate dynamicMakeURL(\n\t\troute: string,\n\t\thash: string,\n\t\t{ forceStatic = false, ...options }: Readonly<ImageURLOptions> = {},\n\t): string {\n\t\treturn this.makeURL(route, !forceStatic && hash.startsWith('a_') ? { ...options, extension: 'gif' } : options);\n\t}\n\n\t/**\n\t * Constructs the URL for the resource\n\t * @param route The base cdn route\n\t * @param options The extension/size options for the link\n\t */\n\tprivate makeURL(\n\t\troute: string,\n\t\t{ allowedExtensions = ALLOWED_EXTENSIONS, extension = 'webp', size }: Readonly<MakeURLOptions> = {},\n\t): string {\n\t\textension = String(extension).toLowerCase();\n\n\t\tif (!allowedExtensions.includes(extension)) {\n\t\t\tthrow new RangeError(`Invalid extension provided: ${extension}\\nMust be one of: ${allowedExtensions.join(', ')}`);\n\t\t}\n\n\t\tif (size && !ALLOWED_SIZES.includes(size)) {\n\t\t\tthrow new RangeError(`Invalid size provided: ${size}\\nMust be one of: ${ALLOWED_SIZES.join(', ')}`);\n\t\t}\n\n\t\tconst url = new URL(`${this.base}${route}.${extension}`);\n\n\t\tif (size) {\n\t\t\turl.searchParams.set('size', String(size));\n\t\t}\n\n\t\treturn url.toString();\n\t}\n}\n","import type { InternalRequest, RawFile } from '../RequestManager';\n\ninterface DiscordErrorFieldInformation {\n\tcode: string;\n\tmessage: string;\n}\n\ninterface DiscordErrorGroupWrapper {\n\t_errors: DiscordError[];\n}\n\ntype DiscordError = DiscordErrorGroupWrapper | DiscordErrorFieldInformation | { [k: string]: DiscordError } | string;\n\nexport interface DiscordErrorData {\n\tcode: number;\n\tmessage: string;\n\terrors?: DiscordError;\n}\n\nexport interface OAuthErrorData {\n\terror: string;\n\terror_description?: string;\n}\n\nexport interface RequestBody {\n\tfiles: RawFile[] | undefined;\n\tjson: unknown | undefined;\n}\n\nfunction isErrorGroupWrapper(error: DiscordError): error is DiscordErrorGroupWrapper {\n\treturn Reflect.has(error as Record<string, unknown>, '_errors');\n}\n\nfunction isErrorResponse(error: DiscordError): error is DiscordErrorFieldInformation {\n\treturn typeof Reflect.get(error as Record<string, unknown>, 'message') === 'string';\n}\n\n/**\n * Represents an API error returned by Discord\n * @extends Error\n */\nexport class DiscordAPIError extends Error {\n\tpublic requestBody: RequestBody;\n\n\t/**\n\t * @param rawError The error reported by Discord\n\t * @param code The error code reported by Discord\n\t * @param status The status code of the response\n\t * @param method The method of the request that erred\n\t * @param url The url of the request that erred\n\t * @param bodyData The unparsed data for the request that errored\n\t */\n\tpublic constructor(\n\t\tpublic rawError: DiscordErrorData | OAuthErrorData,\n\t\tpublic code: number | string,\n\t\tpublic status: number,\n\t\tpublic method: string,\n\t\tpublic url: string,\n\t\tbodyData: Pick<InternalRequest, 'files' | 'body'>,\n\t) {\n\t\tsuper(DiscordAPIError.getMessage(rawError));\n\n\t\tthis.requestBody = { files: bodyData.files, json: bodyData.body };\n\t}\n\n\t/**\n\t * The name of the error\n\t */\n\tpublic override get name(): string {\n\t\treturn `${DiscordAPIError.name}[${this.code}]`;\n\t}\n\n\tprivate static getMessage(error: DiscordErrorData | OAuthErrorData) {\n\t\tlet flattened = '';\n\t\tif ('code' in error) {\n\t\t\tif (error.errors) {\n\t\t\t\tflattened = [...this.flattenDiscordError(error.errors)].join('\\n');\n\t\t\t}\n\t\t\treturn error.message && flattened\n\t\t\t\t? `${error.message}\\n${flattened}`\n\t\t\t\t: error.message || flattened || 'Unknown Error';\n\t\t}\n\t\treturn error.error_description ?? 'No Description';\n\t}\n\n\tprivate static *flattenDiscordError(obj: DiscordError, key = ''): IterableIterator<string> {\n\t\tif (isErrorResponse(obj)) {\n\t\t\treturn yield `${key.length ? `${key}[${obj.code}]` : `${obj.code}`}: ${obj.message}`.trim();\n\t\t}\n\n\t\tfor (const [k, v] of Object.entries(obj)) {\n\t\t\tconst nextKey = k.startsWith('_') ? key : key ? (Number.isNaN(Number(k)) ? `${key}.${k}` : `${key}[${k}]`) : k;\n\n\t\t\tif (typeof v === 'string') {\n\t\t\t\tyield v;\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n\t\t\t} else if (isErrorGroupWrapper(v)) {\n\t\t\t\tfor (const error of v._errors) {\n\t\t\t\t\tyield* this.flattenDiscordError(error, nextKey);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n\t\t\t\tyield* this.flattenDiscordError(v, nextKey);\n\t\t\t}\n\t\t}\n\t}\n}\n","import type { RequestBody } from './DiscordAPIError';\nimport type { InternalRequest } from '../RequestManager';\n\n/**\n * Represents a HTTP error\n */\nexport class HTTPError extends Error {\n\tpublic requestBody: RequestBody;\n\n\t/**\n\t * @param name The name of the error\n\t * @param status The status code of the response\n\t * @param method The method of the request that erred\n\t * @param url The url of the request that erred\n\t * @param bodyData The unparsed data for the request that errored\n\t */\n\tpublic constructor(\n\t\tpublic override name: string,\n\t\tpublic status: number,\n\t\tpublic method: string,\n\t\tpublic url: string,\n\t\tbodyData: Pick<InternalRequest, 'files' | 'body'>,\n\t) {\n\t\tsuper();\n\n\t\tthis.requestBody = { files: bodyData.files, json: bodyData.body };\n\t}\n}\n","import type { RateLimitData } from '../REST';\n\nexport class RateLimitError extends Error implements RateLimitData {\n\tpublic timeToReset: number;\n\tpublic limit: number;\n\tpublic method: string;\n\tpublic hash: string;\n\tpublic url: string;\n\tpublic route: string;\n\tpublic majorParameter: string;\n\tpublic global: boolean;\n\tpublic constructor({ timeToReset, limit, method, hash, url, route, majorParameter, global }: RateLimitData) {\n\t\tsuper();\n\t\tthis.timeToReset = timeToReset;\n\t\tthis.limit = limit;\n\t\tthis.method = method;\n\t\tthis.hash = hash;\n\t\tthis.url = url;\n\t\tthis.route = route;\n\t\tthis.majorParameter = majorParameter;\n\t\tthis.global = global;\n\t}\n\n\t/**\n\t * The name of the error\n\t */\n\tpublic override get name(): string {\n\t\treturn `${RateLimitError.name}[${this.route}]`;\n\t}\n}\n","import { Blob } from 'node:buffer';\nimport { EventEmitter } from 'node:events';\nimport Collection from '@discordjs/collection';\nimport { DiscordSnowflake } from '@sapphire/snowflake';\nimport { FormData, type RequestInit, type BodyInit, type Dispatcher, Agent } from 'undici';\nimport type { RESTOptions, RestEvents, RequestOptions } from './REST';\nimport type { IHandler } from './handlers/IHandler';\nimport { SequentialHandler } from './handlers/SequentialHandler';\nimport { DefaultRestOptions, DefaultUserAgent, RESTEvents } from './utils/constants';\nimport { resolveBody } from './utils/utils';\n\n/**\n * Represents a file to be added to the request\n */\nexport interface RawFile {\n\t/**\n\t * The name of the file\n\t */\n\tname: string;\n\t/**\n\t * An explicit key to use for key of the formdata field for this file.\n\t * When not provided, the index of the file in the files array is used in the form `files[${index}]`.\n\t * If you wish to alter the placeholder snowflake, you must provide this property in the same form (`files[${placeholder}]`)\n\t */\n\tkey?: string;\n\t/**\n\t * The actual data for the file\n\t */\n\tdata: string | number | boolean | Buffer;\n}\n\n/**\n * Represents possible data to be given to an endpoint\n */\nexport interface RequestData {\n\t/**\n\t * Whether to append JSON data to form data instead of `payload_json` when sending files\n\t */\n\tappendToFormData?: boolean;\n\t/**\n\t * If this request needs the `Authorization` header\n\t * @default true\n\t */\n\tauth?: boolean;\n\t/**\n\t * The authorization prefix to use for this request, useful if you use this with bearer tokens\n\t * @default 'Bot'\n\t */\n\tauthPrefix?: 'Bot' | 'Bearer';\n\t/**\n\t * The body to send to this request.\n\t * If providing as BodyInit, set `passThroughBody: true`\n\t */\n\tbody?: BodyInit | unknown;\n\t/**\n\t * The {@link https://undici.nodejs.org/#/docs/api/Agent Agent} to use for the request.\n\t */\n\tdispatcher?: Agent;\n\t/**\n\t * Files to be attached to this request\n\t */\n\tfiles?: RawFile[] | undefined;\n\t/**\n\t * Additional headers to add to this request\n\t */\n\theaders?: Record<string, string>;\n\t/**\n\t * Whether to pass-through the body property directly to `fetch()`.\n\t * <warn>This only applies when files is NOT present</warn>\n\t */\n\tpassThroughBody?: boolean;\n\t/**\n\t * Query string parameters to append to the called endpoint\n\t */\n\tquery?: URLSearchParams;\n\t/**\n\t * Reason to show in the audit logs\n\t */\n\treason?: string;\n\t/**\n\t * If this request should be versioned\n\t * @default true\n\t */\n\tversioned?: boolean;\n}\n\n/**\n * Possible headers for an API call\n */\nexport interface RequestHeaders {\n\tAuthorization?: string;\n\t'User-Agent': string;\n\t'X-Audit-Log-Reason'?: string;\n}\n\n/**\n * Possible API methods to be used when doing requests\n */\nexport const enum RequestMethod {\n\tDelete = 'DELETE',\n\tGet = 'GET',\n\tPatch = 'PATCH',\n\tPost = 'POST',\n\tPut = 'PUT',\n}\n\nexport type RouteLike = `/${string}`;\n\n/**\n * Internal request options\n *\n * @internal\n */\nexport interface InternalRequest extends RequestData {\n\tmethod: RequestMethod;\n\tfullRoute: RouteLike;\n}\n\nexport type HandlerRequestData = Pick<InternalRequest, 'files' | 'body' | 'auth'>;\n\n/**\n * Parsed route data for an endpoint\n *\n * @internal\n */\nexport interface RouteData {\n\tmajorParameter: string;\n\tbucketRoute: string;\n\toriginal: RouteLike;\n}\n\n/**\n * Represents a hash and its associated fields\n *\n * @internal\n */\nexport interface HashData {\n\tvalue: string;\n\tlastAccess: number;\n}\n\nexport interface RequestManager {\n\ton: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);\n\n\tonce: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);\n\n\temit: (<K extends keyof RestEvents>(event: K, ...args: RestEvents[K]) => boolean) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, ...args: any[]) => boolean);\n\n\toff: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);\n\n\tremoveAllListeners: (<K extends keyof RestEvents>(event?: K) => this) &\n\t\t(<S extends string | symbol>(event?: Exclude<S, keyof RestEvents>) => this);\n}\n\n/**\n * Represents the class that manages handlers for endpoints\n */\nexport class RequestManager extends EventEmitter {\n\t/**\n\t * The {@link https://undici.nodejs.org/#/docs/api/Agent Agent} for all requests\n\t * performed by this manager.\n\t */\n\tpublic agent: Dispatcher | null = null;\n\t/**\n\t * The number of requests remaining in the global bucket\n\t */\n\tpublic globalRemaining: number;\n\n\t/**\n\t * The promise used to wait out the global rate limit\n\t */\n\tpublic globalDelay: Promise<void> | null = null;\n\n\t/**\n\t * The timestamp at which the global bucket resets\n\t */\n\tpublic globalReset = -1;\n\n\t/**\n\t * API bucket hashes that are cached from provided routes\n\t */\n\tpublic readonly hashes = new Collection<string, HashData>();\n\n\t/**\n\t * Request handlers created from the bucket hash and the major parameters\n\t */\n\tpublic readonly handlers = new Collection<string, IHandler>();\n\n\t// eslint-disable-next-line @typescript-eslint/explicit-member-accessibility\n\t#token: string | null = null;\n\n\tprivate hashTimer!: NodeJS.Timer;\n\tprivate handlerTimer!: NodeJS.Timer;\n\n\tpublic readonly options: RESTOptions;\n\n\tpublic constructor(options: Partial<RESTOptions>) {\n\t\tsuper();\n\t\tthis.options = { ...DefaultRestOptions, ...options };\n\t\tthis.options.offset = Math.max(0, this.options.offset);\n\t\tthis.globalRemaining = this.options.globalRequestsPerSecond;\n\t\tthis.agent = options.agent ?? null;\n\n\t\t// Start sweepers\n\t\tthis.setupSweepers();\n\t}\n\n\tprivate setupSweepers() {\n\t\tconst validateMaxInterval = (interval: number) => {\n\t\t\tif (interval > 14_400_000) {\n\t\t\t\tthrow new Error('Cannot set an interval greater than 4 hours');\n\t\t\t}\n\t\t};\n\n\t\tif (this.options.hashSweepInterval !== 0 && this.options.hashSweepInterval !== Infinity) {\n\t\t\tvalidateMaxInterval(this.options.hashSweepInterval);\n\t\t\tthis.hashTimer = setInterval(() => {\n\t\t\t\tconst sweptHashes = new Collection<string, HashData>();\n\t\t\t\tconst currentDate = Date.now();\n\n\t\t\t\t// Begin sweeping hash based on lifetimes\n\t\t\t\tthis.hashes.sweep((v, k) => {\n\t\t\t\t\t// `-1` indicates a global hash\n\t\t\t\t\tif (v.lastAccess === -1) return false;\n\n\t\t\t\t\t// Check if lifetime has been exceeded\n\t\t\t\t\tconst shouldSweep = Math.floor(currentDate - v.lastAccess) > this.options.hashLifetime;\n\n\t\t\t\t\t// Add hash to collection of swept hashes\n\t\t\t\t\tif (shouldSweep) {\n\t\t\t\t\t\t// Add to swept hashes\n\t\t\t\t\t\tsweptHashes.set(k, v);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Emit debug information\n\t\t\t\t\tthis.emit(RESTEvents.Debug, `Hash ${v.value} for ${k} swept due to lifetime being exceeded`);\n\n\t\t\t\t\treturn shouldSweep;\n\t\t\t\t});\n\n\t\t\t\t// Fire event\n\t\t\t\tthis.emit(RESTEvents.HashSweep, sweptHashes);\n\t\t\t}, this.options.hashSweepInterval).unref();\n\t\t}\n\n\t\tif (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Infinity) {\n\t\t\tvalidateMaxInterval(this.options.handlerSweepInterval);\n\t\t\tthis.handlerTimer = setInterval(() => {\n\t\t\t\tconst sweptHandlers = new Collection<string, IHandler>();\n\n\t\t\t\t// Begin sweeping handlers based on activity\n\t\t\t\tthis.handlers.sweep((v, k) => {\n\t\t\t\t\tconst { inactive } = v;\n\n\t\t\t\t\t// Collect inactive handlers\n\t\t\t\t\tif (inactive) {\n\t\t\t\t\t\tsweptHandlers.set(k, v);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.emit(RESTEvents.Debug, `Handler ${v.id} for ${k} swept due to being inactive`);\n\t\t\t\t\treturn inactive;\n\t\t\t\t});\n\n\t\t\t\t// Fire event\n\t\t\t\tthis.emit(RESTEvents.HandlerSweep, sweptHandlers);\n\t\t\t}, this.options.handlerSweepInterval).unref();\n\t\t}\n\t}\n\n\t/**\n\t * Sets the default agent to use for requests performed by this manager\n\t * @param agent The agent to use\n\t */\n\tpublic setAgent(agent: Dispatcher) {\n\t\tthis.agent = agent;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the authorization token that should be used for requests\n\t * @param token The authorization token to use\n\t */\n\tpublic setToken(token: string) {\n\t\tthis.#token = token;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Queues a request to be sent\n\t * @param request All the information needed to make a request\n\t * @returns The response from the api request\n\t */\n\tpublic async queueRequest(request: InternalRequest): Promise<Dispatcher.ResponseData> {\n\t\t// Generalize the endpoint to its route data\n\t\tconst routeId = RequestManager.generateRouteData(request.fullRoute, request.method);\n\t\t// Get the bucket hash for the generic route, or point to a global route otherwise\n\t\tconst hash = this.hashes.get(`${request.method}:${routeId.bucketRoute}`) ?? {\n\t\t\tvalue: `Global(${request.method}:${routeId.bucketRoute})`,\n\t\t\tlastAccess: -1,\n\t\t};\n\n\t\t// Get the request handler for the obtained hash, with its major parameter\n\t\tconst handler =\n\t\t\tthis.handlers.get(`${hash.value}:${routeId.majorParameter}`) ??\n\t\t\tthis.createHandler(hash.value, routeId.majorParameter);\n\n\t\t// Resolve the request into usable fetch options\n\t\tconst { url, fetchOptions } = await this.resolveRequest(request);\n\n\t\t// Queue the request\n\t\treturn handler.queueRequest(routeId, url, fetchOptions, {\n\t\t\tbody: request.body,\n\t\t\tfiles: request.files,\n\t\t\tauth: request.auth !== false,\n\t\t});\n\t}\n\n\t/**\n\t * Creates a new rate limit handler from a hash, based on the hash and the major parameter\n\t * @param hash The hash for the route\n\t * @param majorParameter The major parameter for this handler\n\t * @private\n\t */\n\tprivate createHandler(hash: string, majorParameter: string) {\n\t\t// Create the async request queue to handle requests\n\t\tconst queue = new SequentialHandler(this, hash, majorParameter);\n\t\t// Save the queue based on its id\n\t\tthis.handlers.set(queue.id, queue);\n\n\t\treturn queue;\n\t}\n\n\t/**\n\t * Formats the request data to a usable format for fetch\n\t * @param request The request data\n\t */\n\tprivate async resolveRequest(request: InternalRequest): Promise<{ url: string; fetchOptions: RequestOptions }> {\n\t\tconst { options } = this;\n\n\t\tlet query = '';\n\n\t\t// If a query option is passed, use it\n\t\tif (request.query) {\n\t\t\tconst resolvedQuery = request.query.toString();\n\t\t\tif (resolvedQuery !== '') {\n\t\t\t\tquery = `?${resolvedQuery}`;\n\t\t\t}\n\t\t}\n\n\t\t// Create the required headers\n\t\tconst headers: RequestHeaders = {\n\t\t\t...this.options.headers,\n\t\t\t'User-Agent': `${DefaultUserAgent} ${options.userAgentAppendix}`.trim(),\n\t\t};\n\n\t\t// If this request requires authorization (allowing non-\"authorized\" requests for webhooks)\n\t\tif (request.auth !== false) {\n\t\t\t// If we haven't received a token, throw an error\n\t\t\tif (!this.#token) {\n\t\t\t\tthrow new Error('Expected token to be set for this request, but none was present');\n\t\t\t}\n\n\t\t\theaders.Authorization = `${request.authPrefix ?? this.options.authPrefix} ${this.#token}`;\n\t\t}\n\n\t\t// If a reason was set, set it's appropriate header\n\t\tif (request.reason?.length) {\n\t\t\theaders['X-Audit-Log-Reason'] = encodeURIComponent(request.reason);\n\t\t}\n\n\t\t// Format the full request URL (api base, optional version, endpoint, optional querystring)\n\t\tconst url = `${options.api}${request.versioned === false ? '' : `/v${options.version}`}${\n\t\t\trequest.fullRoute\n\t\t}${query}`;\n\n\t\tlet finalBody: RequestInit['body'];\n\t\tlet additionalHeaders: Record<string, string> = {};\n\n\t\tif (request.files?.length) {\n\t\t\tconst formData = new FormData();\n\n\t\t\t// Attach all files to the request\n\t\t\tfor (const [index, file] of request.files.entries()) {\n\t\t\t\tconst fileKey = file.key ?? `files[${index}]`;\n\n\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/FormData/append#parameters\n\t\t\t\t// FormData.append only accepts a string or Blob.\n\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob#parameters\n\t\t\t\t// The Blob constructor accepts TypedArray/ArrayBuffer, strings, and Blobs.\n\t\t\t\tif (Buffer.isBuffer(file.data) || typeof file.data === 'string') {\n\t\t\t\t\tformData.append(fileKey, new Blob([file.data]), file.name);\n\t\t\t\t} else {\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n\t\t\t\t\tformData.append(fileKey, new Blob([`${file.data}`]), file.name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If a JSON body was added as well, attach it to the form data, using payload_json unless otherwise specified\n\t\t\t// eslint-disable-next-line no-eq-null\n\t\t\tif (request.body != null) {\n\t\t\t\tif (request.appendToFormData) {\n\t\t\t\t\tfor (const [key, value] of Object.entries(request.body as Record<string, unknown>)) {\n\t\t\t\t\t\tformData.append(key, value);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tformData.append('payload_json', JSON.stringify(request.body));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the final body to the form data\n\t\t\tfinalBody = formData;\n\n\t\t\t// eslint-disable-next-line no-eq-null\n\t\t} else if (request.body != null) {\n\t\t\tif (request.passThroughBody) {\n\t\t\t\tfinalBody = request.body as BodyInit;\n\t\t\t} else {\n\t\t\t\t// Stringify the JSON data\n\t\t\t\tfinalBody = JSON.stringify(request.body);\n\t\t\t\t// Set the additional headers to specify the content-type\n\t\t\t\tadditionalHeaders = { 'Content-Type': 'application/json' };\n\t\t\t}\n\t\t}\n\n\t\tfinalBody = await resolveBody(finalBody);\n\n\t\tconst fetchOptions: RequestOptions = {\n\t\t\t// eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n\t\t\theaders: { ...(request.headers ?? {}), ...additionalHeaders, ...headers } as Record<string, string>,\n\t\t\tmethod: request.method.toUpperCase() as Dispatcher.HttpMethod,\n\t\t};\n\n\t\tif (finalBody !== undefined) {\n\t\t\tfetchOptions.body = finalBody as Exclude<RequestOptions['body'], undefined>;\n\t\t}\n\n\t\t// Prioritize setting an agent per request, use the agent for this instance otherwise.\n\t\tfetchOptions.dispatcher = request.dispatcher ?? this.agent ?? undefined!;\n\n\t\treturn { url, fetchOptions };\n\t}\n\n\t/**\n\t * Stops the hash sweeping interval\n\t */\n\tpublic clearHashSweeper() {\n\t\tclearInterval(this.hashTimer);\n\t}\n\n\t/**\n\t * Stops the request handler sweeping interval\n\t */\n\tpublic clearHandlerSweeper() {\n\t\tclearInterval(this.handlerTimer);\n\t}\n\n\t/**\n\t * Generates route data for an endpoint:method\n\t * @param endpoint The raw endpoint to generalize\n\t * @param method The HTTP method this endpoint is called without\n\t * @private\n\t */\n\tprivate static generateRouteData(endpoint: RouteLike, method: RequestMethod): RouteData {\n\t\tconst majorIdMatch = /^\\/(?:channels|guilds|webhooks)\\/(\\d{16,19})/.exec(endpoint);\n\n\t\t// Get the major id for this route - global otherwise\n\t\tconst majorId = majorIdMatch?.[1] ?? 'global';\n\n\t\tconst baseRoute = endpoint\n\t\t\t// Strip out all ids\n\t\t\t.replace(/\\d{16,19}/g, ':id')\n\t\t\t// Strip out reaction as they fall under the same bucket\n\t\t\t.replace(/\\/reactions\\/(.*)/, '/reactions/:reaction');\n\n\t\tlet exceptions = '';\n\n\t\t// Hard-Code Old Message Deletion Exception (2 week+ old messages are a different bucket)\n\t\t// https://github.com/discord/discord-api-docs/issues/1295\n\t\tif (method === RequestMethod.Delete && baseRoute === '/channels/:id/messages/:id') {\n\t\t\tconst id = /\\d{16,19}$/.exec(endpoint)![0]!;\n\t\t\tconst timestamp = DiscordSnowflake.timestampFrom(id);\n\t\t\tif (Date.now() - timestamp > 1000 * 60 * 60 * 24 * 14) {\n\t\t\t\texceptions += '/Delete Old Message';\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tmajorParameter: majorId,\n\t\t\tbucketRoute: baseRoute + exceptions,\n\t\t\toriginal: endpoint,\n\t\t};\n\t}\n}\n","import { setTimeout as sleep } from 'node:timers/promises';\nimport { AsyncQueue } from '@sapphire/async-queue';\nimport { request, type Dispatcher } from 'undici';\nimport type { IHandler } from './IHandler';\nimport type { RateLimitData, RequestOptions } from '../REST';\nimport type { HandlerRequestData, RequestManager, RouteData } from '../RequestManager';\nimport { DiscordAPIError, DiscordErrorData, OAuthErrorData } from '../errors/DiscordAPIError';\nimport { HTTPError } from '../errors/HTTPError';\nimport { RateLimitError } from '../errors/RateLimitError';\nimport { RESTEvents } from '../utils/constants';\nimport { hasSublimit, parseHeader, parseResponse } from '../utils/utils';\n\n/* Invalid request limiting is done on a per-IP basis, not a per-token basis.\n * The best we can do is track invalid counts process-wide (on the theory that\n * users could have multiple bots run from one process) rather than per-bot.\n * Therefore, store these at file scope here rather than in the client's\n * RESTManager object.\n */\nlet invalidCount = 0;\nlet invalidCountResetTime: number | null = null;\n\nconst enum QueueType {\n\tStandard,\n\tSublimit,\n}\n\n/**\n * The structure used to handle requests for a given bucket\n */\nexport class SequentialHandler implements IHandler {\n\t/**\n\t * The unique id of the handler\n\t */\n\tpublic readonly id: string;\n\n\t/**\n\t * The time this rate limit bucket will reset\n\t */\n\tprivate reset = -1;\n\n\t/**\n\t * The remaining requests that can be made before we are rate limited\n\t */\n\tprivate remaining = 1;\n\n\t/**\n\t * The total number of requests that can be made before we are rate limited\n\t */\n\tprivate limit = Infinity;\n\n\t/**\n\t * The interface used to sequence async requests sequentially\n\t */\n\t// eslint-disable-next-line @typescript-eslint/explicit-member-accessibility\n\t#asyncQueue = new AsyncQueue();\n\n\t/**\n\t * The interface used to sequence sublimited async requests sequentially\n\t */\n\t// eslint-disable-next-line @typescript-eslint/explicit-member-accessibility\n\t#sublimitedQueue: AsyncQueue | null = null;\n\n\t/**\n\t * A promise wrapper for when the sublimited queue is finished being processed or null when not being processed\n\t */\n\t// eslint-disable-next-line @typescript-eslint/explicit-member-accessibility\n\t#sublimitPromise: { promise: Promise<void>; resolve: () => void } | null = null;\n\n\t/**\n\t * Whether the sublimit queue needs to be shifted in the finally block\n\t */\n\t// eslint-disable-next-line @typescript-eslint/explicit-member-accessibility\n\t#shiftSublimit = false;\n\n\t/**\n\t * @param manager The request manager\n\t * @param hash The hash that this RequestHandler handles\n\t * @param majorParameter The major parameter for this handler\n\t */\n\tpublic constructor(\n\t\tprivate readonly manager: RequestManager,\n\t\tprivate readonly hash: string,\n\t\tprivate readonly majorParameter: string,\n\t) {\n\t\tthis.id = `${hash}:${majorParameter}`;\n\t}\n\n\t/**\n\t * If the bucket is currently inactive (no pending requests)\n\t */\n\tpublic get inactive(): boolean {\n\t\treturn (\n\t\t\tthis.#asyncQueue.remaining === 0 &&\n\t\t\t(this.#sublimitedQueue === null || this.#sublimitedQueue.remaining === 0) &&\n\t\t\t!this.limited\n\t\t);\n\t}\n\n\t/**\n\t * If the rate limit bucket is currently limited by the global limit\n\t */\n\tprivate get globalLimited(): boolean {\n\t\treturn this.manager.globalRemaining <= 0 && Date.now() < this.manager.globalReset;\n\t}\n\n\t/**\n\t * If the rate limit bucket is currently limited by its limit\n\t */\n\tprivate get localLimited(): boolean {\n\t\treturn this.remaining <= 0 && Date.now() < this.reset;\n\t}\n\n\t/**\n\t * If the rate limit bucket is currently limited\n\t */\n\tprivate get limited(): boolean {\n\t\treturn this.globalLimited || this.localLimited;\n\t}\n\n\t/**\n\t * The time until queued requests can continue\n\t */\n\tprivate get timeToReset(): number {\n\t\treturn this.reset + this.manager.options.offset - Date.now();\n\t}\n\n\t/**\n\t * Emits a debug message\n\t * @param message The message to debug\n\t */\n\tprivate debug(message: string) {\n\t\tthis.manager.emit(RESTEvents.Debug, `[REST ${this.id}] ${message}`);\n\t}\n\n\t/**\n\t * Delay all requests for the specified amount of time, handling global rate limits\n\t * @param time The amount of time to delay all requests for\n\t * @returns\n\t */\n\tprivate async globalDelayFor(time: number): Promise<void> {\n\t\tawait sleep(time, undefined, { ref: false });\n\t\tthis.manager.globalDelay = null;\n\t}\n\n\t/*\n\t * Determines whether the request should be queued or whether a RateLimitError should be thrown\n\t */\n\tprivate async onRateLimit(rateLimitData: RateLimitData) {\n\t\tconst { options } = this.manager;\n\t\tif (!options.rejectOnRateLimit) return;\n\n\t\tconst shouldThrow =\n\t\t\ttypeof options.rejectOnRateLimit === 'function'\n\t\t\t\t? await options.rejectOnRateLimit(rateLimitData)\n\t\t\t\t: options.rejectOnRateLimit.some((route) => rateLimitData.route.startsWith(route.toLowerCase()));\n\t\tif (shouldThrow) {\n\t\t\tthrow new RateLimitError(rateLimitData);\n\t\t}\n\t}\n\n\t/**\n\t * Queues a request to be sent\n\t * @param routeId The generalized api route with literal ids for major parameters\n\t * @param url The url to do the request on\n\t * @param options All the information needed to make a request\n\t * @param requestData Extra data from the user's request needed for errors and additional processing\n\t */\n\tpublic async queueRequest(\n\t\trouteId: RouteData,\n\t\turl: string,\n\t\toptions: RequestOptions,\n\t\trequestData: HandlerRequestData,\n\t): Promise<Dispatcher.ResponseData> {\n\t\tlet queue = this.#asyncQueue;\n\t\tlet queueType = QueueType.Standard;\n\t\t// Separate sublimited requests when already sublimited\n\t\tif (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {\n\t\t\tqueue = this.#sublimitedQueue!;\n\t\t\tqueueType = QueueType.Sublimit;\n\t\t}\n\t\t// Wait for any previous requests to be completed before this one is run\n\t\tawait queue.wait();\n\t\t// This set handles retroactively sublimiting requests\n\t\tif (queueType === QueueType.Standard) {\n\t\t\tif (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {\n\t\t\t\t/**\n\t\t\t\t * Remove the request from the standard queue, it should never be possible to get here while processing the\n\t\t\t\t * sublimit queue so there is no need to worry about shifting the wrong request\n\t\t\t\t */\n\t\t\t\tqueue = this.#sublimitedQueue!;\n\t\t\t\tconst wait = queue.wait();\n\t\t\t\tthis.#asyncQueue.shift();\n\t\t\t\tawait wait;\n\t\t\t} else if (this.#sublimitPromise) {\n\t\t\t\t// Stall requests while the sublimit queue gets processed\n\t\t\t\tawait this.#sublimitPromise.promise;\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\t// Make the request, and return the results\n\t\t\treturn await this.runRequest(routeId, url, options, requestData);\n\t\t} finally {\n\t\t\t// Allow the next request to fire\n\t\t\tqueue.shift();\n\t\t\tif (this.#shiftSublimit) {\n\t\t\t\tthis.#shiftSublimit = false;\n\t\t\t\tthis.#sublimitedQueue?.shift();\n\t\t\t}\n\t\t\t// If this request is the last request in a sublimit\n\t\t\tif (this.#sublimitedQueue?.remaining === 0) {\n\t\t\t\tthis.#sublimitPromise?.resolve();\n\t\t\t\tthis.#sublimitedQueue = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The method that actually makes the request to the api, and updates info about the bucket accordingly\n\t * @param routeId The generalized api route with literal ids for major parameters\n\t * @param url The fully resolved url to make the request to\n\t * @param options The fetch options needed to make the request\n\t * @param requestData Extra data from the user's request needed for errors and additional processing\n\t * @param retries The number of retries this request has already attempted (recursion)\n\t */\n\tprivate async runRequest(\n\t\trouteId: RouteData,\n\t\turl: string,\n\t\toptions: RequestOptions,\n\t\trequestData: HandlerRequestData,\n\t\tretries = 0,\n\t): Promise<Dispatcher.ResponseData> {\n\t\t/*\n\t\t * After calculations have been done, pre-emptively stop further requests\n\t\t * Potentially loop until this task can run if e.g. the global rate limit is hit twice\n\t\t */\n\t\twhile (this.limited) {\n\t\t\tconst isGlobal = this.globalLimited;\n\t\t\tlet limit: number;\n\t\t\tlet timeout: number;\n\t\t\tlet delay: Promise<void>;\n\n\t\t\tif (isGlobal) {\n\t\t\t\t// Set RateLimitData based on the global limit\n\t\t\t\tlimit = this.manager.options.globalRequestsPerSecond;\n\t\t\t\ttimeout = this.manager.globalReset + this.manager.options.offset - Date.now();\n\t\t\t\t// If this is the first task to reach the global timeout, set the global delay\n\t\t\t\tif (!this.manager.globalDelay) {\n\t\t\t\t\t// The global delay function clears the global delay state when it is resolved\n\t\t\t\t\tthis.manager.globalDelay = this.globalDelayFor(timeout);\n\t\t\t\t}\n\t\t\t\tdelay = this.manager.globalDelay;\n\t\t\t} else {\n\t\t\t\t// Set RateLimitData based on the route-specific limit\n\t\t\t\tlimit = this.limit;\n\t\t\t\ttimeout = this.timeToReset;\n\t\t\t\tdelay = sleep(timeout);\n\t\t\t}\n\t\t\tconst rateLimitData: RateLimitData = {\n\t\t\t\ttimeToReset: timeout,\n\t\t\t\tlimit,\n\t\t\t\tmethod: options.method ?? 'get',\n\t\t\t\thash: this.hash,\n\t\t\t\turl,\n\t\t\t\troute: routeId.bucketRoute,\n\t\t\t\tmajorParameter: this.majorParameter,\n\t\t\t\tglobal: isGlobal,\n\t\t\t};\n\t\t\t// Let library users know they have hit a rate limit\n\t\t\tthis.manager.emit(RESTEvents.RateLimited, rateLimitData);\n\t\t\t// Determine whether a RateLimitError should be thrown\n\t\t\tawait this.onRateLimit(rateLimitData);\n\t\t\t// When not erroring, emit debug for what is happening\n\t\t\tif (isGlobal) {\n\t\t\t\tthis.debug(`Global rate limit hit, blocking all requests for ${timeout}ms`);\n\t\t\t} else {\n\t\t\t\tthis.debug(`Waiting ${timeout}ms for rate limit to pass`);\n\t\t\t}\n\t\t\t// Wait the remaining time left before the rate limit resets\n\t\t\tawait delay;\n\t\t}\n\t\t// As the request goes out, update the global usage information\n\t\tif (!this.manager.globalReset || this.manager.globalReset < Date.now()) {\n\t\t\tthis.manager.globalReset = Date.now() + 1000;\n\t\t\tthis.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;\n\t\t}\n\t\tthis.manager.globalRemaining--;\n\n\t\tconst method = options.method ?? 'get';\n\n\t\tconst controller = new AbortController();\n\t\tconst timeout = setTimeout(() => controller.abort(), this.manager.options.timeout).unref();\n\t\tlet res: Dispatcher.ResponseData;\n\n\t\ttry {\n\t\t\tres = await request(url, { ...options, signal: controller.signal });\n\t\t} catch (error: unknown) {\n\t\t\t// Retry the specified number of times for possible timed out requests\n\t\t\tif (error instanceof Error && error.name === 'AbortError' && retries !== this.manager.options.retries) {\n\t\t\t\treturn await this.runRequest(routeId, url, options, requestData, ++retries);\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tclearTimeout(timeout);\n\t\t}\n\n\t\tif (this.manager.listenerCount(RESTEvents.Response)) {\n\t\t\tthis.manager.emit(\n\t\t\t\tRESTEvents.Response,\n\t\t\t\t{\n\t\t\t\t\tmethod,\n\t\t\t\t\tpath: routeId.original,\n\t\t\t\t\troute: routeId.bucketRoute,\n\t\t\t\t\toptions,\n\t\t\t\t\tdata: requestData,\n\t\t\t\t\tretries,\n\t\t\t\t},\n\t\t\t\t{ ...res },\n\t\t\t);\n\t\t}\n\n\t\tconst status = res.statusCode;\n\t\tlet retryAfter = 0;\n\n\t\tconst limit = parseHeader(res.headers['x-ratelimit-limit']);\n\t\tconst remaining = parseHeader(res.headers['x-ratelimit-remaining']);\n\t\tconst reset = parseHeader(res.headers['x-ratelimit-reset-after']);\n\t\tconst hash = parseHeader(res.headers['x-ratelimit-bucket']);\n\t\tconst retry = parseHeader(res.headers['retry-after']);\n\n\t\t// Update the total number of requests that can be made before the rate limit resets\n\t\tthis.limit = limit ? Number(limit) : Infinity;\n\t\t// Update the number of remaining requests that can be made before the rate limit resets\n\t\tthis.remaining = remaining ? Number(remaining) : 1;\n\t\t// Update the time when this rate limit resets (reset-after is in seconds)\n\t\tthis.reset = reset ? Number(reset) * 1000 + Date.now() + this.manager.options.offset : Date.now();\n\n\t\t// Amount of time in milliseconds until we should retry if rate limited (globally or otherwise)\n\t\tif (retry) retryAfter = Number(retry) * 1000 + this.manager.options.offset;\n\n\t\t// Handle buckets via the hash header retroactively\n\t\tif (hash && hash !== this.hash) {\n\t\t\t// Let library users know when rate limit buckets have been updated\n\t\t\tthis.debug(['Received bucket hash update', `  Old Hash  : ${this.hash}`, `  New Hash  : ${hash}`].join('\\n'));\n\t\t\t// This queue will eventually be eliminated via attrition\n\t\t\tthis.manager.hashes.set(`${method}:${routeId.bucketRoute}`, { value: hash, lastAccess: Date.now() });\n\t\t} else if (hash) {\n\t\t\t// Handle the case where hash value doesn't change\n\t\t\t// Fetch the hash data from the manager\n\t\t\tconst hashData = this.manager.hashes.get(`${method}:${routeId.bucketRoute}`);\n\n\t\t\t// When fetched, update the last access of the hash\n\t\t\tif (hashData) {\n\t\t\t\thashData.lastAccess = Date.now();\n\t\t\t}\n\t\t}\n\n\t\t// Handle retryAfter, which means we have actually hit a rate limit\n\t\tlet sublimitTimeout: number | null = null;\n\t\tif (retryAfter > 0) {\n\t\t\tif (res.headers['x-ratelimit-global'] !== undefined) {\n\t\t\t\tthis.manager.globalRemaining = 0;\n\t\t\t\tthis.manager.globalReset = Date.now() + retryAfter;\n\t\t\t} else if (!this.localLimited) {\n\t\t\t\t/*\n\t\t\t\t * This is a sublimit (e.g. 2 channel name changes/10 minutes) since the headers don't indicate a\n\t\t\t\t * route-wide rate limit. Don't update remaining or reset to avoid rate limiting the whole\n\t\t\t\t * endpoint, just set a reset time on the request itself to avoid retrying too soon.\n\t\t\t\t */\n\t\t\t\tsublimitTimeout = retryAfter;\n\t\t\t}\n\t\t}\n\n\t\t// Count the invalid requests\n\t\tif (status === 401 || status === 403 || status === 429) {\n\t\t\tif (!invalidCountResetTime || invalidCountResetTime < Date.now()) {\n\t\t\t\tinvalidCountResetTime = Date.now() + 1000 * 60 * 10;\n\t\t\t\tinvalidCount = 0;\n\t\t\t}\n\t\t\tinvalidCount++;\n\n\t\t\tconst emitInvalid =\n\t\t\t\tthis.manager.options.invalidRequestWarningInterval > 0 &&\n\t\t\t\tinvalidCount % this.manager.options.invalidRequestWarningInterval === 0;\n\t\t\tif (emitInvalid) {\n\t\t\t\t// Let library users know periodically about invalid requests\n\t\t\t\tthis.manager.emit(RESTEvents.InvalidRequestWarning, {\n\t\t\t\t\tcount: invalidCount,\n\t\t\t\t\tremainingTime: invalidCountResetTime - Date.now(),\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (status >= 200 && status < 300) {\n\t\t\treturn res;\n\t\t} else if (status === 429) {\n\t\t\t// A rate limit was hit - this may happen if the route isn't associated with an official bucket hash yet, or when first globally rate limited\n\t\t\tconst isGlobal = this.globalLimited;\n\t\t\tlet limit: number;\n\t\t\tlet timeout: number;\n\n\t\t\tif (isGlobal) {\n\t\t\t\t// Set RateLimitData based on the global limit\n\t\t\t\tlimit = this.manager.options.globalRequestsPerSecond;\n\t\t\t\ttimeout = this.manager.globalReset + this.manager.options.offset - Date.now();\n\t\t\t} else {\n\t\t\t\t// Set RateLimitData based on the route-specific limit\n\t\t\t\tlimit = this.limit;\n\t\t\t\ttimeout = this.timeToReset;\n\t\t\t}\n\t\t\tawait this.onRateLimit({\n\t\t\t\ttimeToReset: timeout,\n\t\t\t\tlimit,\n\t\t\t\tmethod,\n\t\t\t\thash: this.hash,\n\t\t\t\turl,\n\t\t\t\troute: routeId.bucketRoute,\n\t\t\t\tmajorParameter: this.majorParameter,\n\t\t\t\tglobal: isGlobal,\n\t\t\t});\n\t\t\tthis.debug(\n\t\t\t\t[\n\t\t\t\t\t'Encountered unexpected 429 rate limit',\n\t\t\t\t\t`  Global         : ${isGlobal.toString()}`,\n\t\t\t\t\t`  Method         : ${method}`,\n\t\t\t\t\t`  URL            : ${url}`,\n\t\t\t\t\t`  Bucket         : ${routeId.bucketRoute}`,\n\t\t\t\t\t`  Major parameter: ${routeId.majorParameter}`,\n\t\t\t\t\t`  Hash           : ${this.hash}`,\n\t\t\t\t\t`  Limit          : ${limit}`,\n\t\t\t\t\t`  Retry After    : ${retryAfter}ms`,\n\t\t\t\t\t`  Sublimit       : ${sublimitTimeout ? `${sublimitTimeout}ms` : 'None'}`,\n\t\t\t\t].join('\\n'),\n\t\t\t);\n\t\t\t// If caused by a sublimit, wait it out here so other requests on the route can be handled\n\t\t\tif (sublimitTimeout) {\n\t\t\t\t// Normally the sublimit queue will not exist, however, if a sublimit is hit while in the sublimit queue, it will\n\t\t\t\tconst firstSublimit = !this.#sublimitedQueue;\n\t\t\t\tif (firstSublimit) {\n\t\t\t\t\tthis.#sublimitedQueue = new AsyncQueue();\n\t\t\t\t\tvoid this.#sublimitedQueue.wait();\n\t\t\t\t\tthis.#asyncQueue.shift();\n\t\t\t\t}\n\t\t\t\tthis.#sublimitPromise?.resolve();\n\t\t\t\tthis.#sublimitPromise = null;\n\t\t\t\tawait sleep(sublimitTimeout, undefined, { ref: false });\n\t\t\t\tlet resolve: () => void;\n\t\t\t\tconst promise = new Promise<void>((res) => (resolve = res));\n\t\t\t\tthis.#sublimitPromise = { promise, resolve: resolve! };\n\t\t\t\tif (firstSublimit) {\n\t\t\t\t\t// Re-queue this request so it can be shifted by the finally\n\t\t\t\t\tawait this.#asyncQueue.wait();\n\t\t\t\t\tthis.#shiftSublimit = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Since this is not a server side issue, the next request should pass, so we don't bump the retries counter\n\t\t\treturn this.runRequest(routeId, url, options, requestData, retries);\n\t\t} else if (status >= 500 && status < 600) {\n\t\t\t// Retry the specified number of times for possible server side issues\n\t\t\tif (retries !== this.manager.options.retries) {\n\t\t\t\treturn this.runRequest(routeId, url, options, requestData, ++retries);\n\t\t\t}\n\t\t\t// We are out of retries, throw an error\n\t\t\tthrow new HTTPError(res.constructor.name, status, method, url, requestData);\n\t\t} else {\n\t\t\t// Handle possible malformed requests\n\t\t\tif (status >= 400 && status < 500) {\n\t\t\t\t// If we receive this status code, it means the token we had is no longer valid.\n\t\t\t\tif (status === 401 && requestData.auth) {\n\t\t\t\t\tthis.manager.setToken(null!);\n\t\t\t\t}\n\t\t\t\t// The request will not succeed for some reason, parse the error returned from the api\n\t\t\t\tconst data = (await parseResponse(res)) as DiscordErrorData | OAuthErrorData;\n\t\t\t\t// throw the API error\n\t\t\t\tthrow new DiscordAPIError(data, 'code' in data ? data.code : data.error, status, method, url, requestData);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\n}\n","import { Blob } from 'node:buffer';\nimport { URLSearchParams } from 'node:url';\nimport { types } from 'node:util';\nimport type { RESTPatchAPIChannelJSONBody } from 'discord-api-types/v10';\nimport { FormData, type Dispatcher, type RequestInit } from 'undici';\nimport type { RequestOptions } from '../REST';\nimport { RequestMethod } from '../RequestManager';\n\nexport function parseHeader(header: string | string[] | undefined): string | undefined {\n\tif (header === undefined) {\n\t\treturn header;\n\t} else if (typeof header === 'string') {\n\t\treturn header;\n\t}\n\n\treturn header.join(';');\n}\n\nfunction serializeSearchParam(value: unknown): string | null {\n\tswitch (typeof value) {\n\t\tcase 'string':\n\t\t\treturn value;\n\t\tcase 'number':\n\t\tcase 'bigint':\n\t\tcase 'boolean':\n\t\t\treturn value.toString();\n\t\tcase 'object':\n\t\t\tif (value === null) return null;\n\t\t\tif (value instanceof Date) {\n\t\t\t\treturn Number.isNaN(value.getTime()) ? null : value.toISOString();\n\t\t\t}\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-base-to-string\n\t\t\tif (typeof value.toString === 'function' && value.toString !== Object.prototype.toString) return value.toString();\n\t\t\treturn null;\n\t\tdefault:\n\t\t\treturn null;\n\t}\n}\n\n/**\n * Creates and populates an URLSearchParams instance from an object, stripping\n * out null and undefined values, while also coercing non-strings to strings.\n * @param options The options to use\n * @returns A populated URLSearchParams instance\n */\nexport function makeURLSearchParams(options?: Record<string, unknown>) {\n\tconst params = new URLSearchParams();\n\tif (!options) return params;\n\n\tfor (const [key, value] of Object.entries(options)) {\n\t\tconst serialized = serializeSearchParam(value);\n\t\tif (serialized !== null) params.append(key, serialized);\n\t}\n\n\treturn params;\n}\n\n/**\n * Converts the response to usable data\n * @param res The fetch response\n */\nexport function parseResponse(res: Dispatcher.ResponseData): Promise<unknown> {\n\tconst header = parseHeader(res.headers['content-type']);\n\tif (header?.startsWith('application/json')) {\n\t\treturn res.body.json();\n\t}\n\n\treturn res.body.arrayBuffer();\n}\n\n/**\n * Check whether a request falls under a sublimit\n * @param bucketRoute The buckets route identifier\n * @param body The options provided as JSON data\n * @param method The HTTP method that will be used to make the request\n * @returns Whether the request falls under a sublimit\n */\nexport function hasSublimit(bucketRoute: string, body?: unknown, method?: string): boolean {\n\t// TODO: Update for new sublimits\n\t// Currently known sublimits:\n\t// Editing channel `name` or `topic`\n\tif (bucketRoute === '/channels/:id') {\n\t\tif (typeof body !== 'object' || body === null) return false;\n\t\t// This should never be a POST body, but just in case\n\t\tif (method !== RequestMethod.Patch) return false;\n\t\tconst castedBody = body as RESTPatchAPIChannelJSONBody;\n\t\treturn ['name', 'topic'].some((key) => Reflect.has(castedBody, key));\n\t}\n\n\t// If we are checking if a request has a sublimit on a route not checked above, sublimit all requests to avoid a flood of 429s\n\treturn true;\n}\n\nexport async function resolveBody(body: RequestInit['body']): Promise<RequestOptions['body']> {\n\t// eslint-disable-next-line no-eq-null\n\tif (body == null) {\n\t\treturn null;\n\t} else if (typeof body === 'string') {\n\t\treturn body;\n\t} else if (types.isUint8Array(body)) {\n\t\treturn body;\n\t} else if (types.isArrayBuffer(body)) {\n\t\treturn new Uint8Array(body);\n\t} else if (body instanceof URLSearchParams) {\n\t\treturn body.toString();\n\t} else if (body instanceof DataView) {\n\t\treturn new Uint8Array(body.buffer);\n\t} else if (body instanceof Blob) {\n\t\treturn new Uint8Array(await body.arrayBuffer());\n\t} else if (body instanceof FormData) {\n\t\treturn body;\n\t\t// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\t} else if ((body as Iterable<Uint8Array>)[Symbol.iterator]) {\n\t\tconst chunks = [...(body as Iterable<Uint8Array>)];\n\t\tconst length = chunks.reduce((a, b) => a + b.length, 0);\n\n\t\tconst uint8 = new Uint8Array(length);\n\t\tlet lengthUsed = 0;\n\n\t\treturn chunks.reduce((a, b) => {\n\t\t\ta.set(b, lengthUsed);\n\t\t\tlengthUsed += b.length;\n\t\t\treturn a;\n\t\t}, uint8);\n\t\t// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\t} else if ((body as AsyncIterable<Uint8Array>)[Symbol.asyncIterator]) {\n\t\tconst chunks: Uint8Array[] = [];\n\n\t\tfor await (const chunk of body as AsyncIterable<Uint8Array>) {\n\t\t\tchunks.push(chunk);\n\t\t}\n\n\t\treturn Buffer.concat(chunks);\n\t}\n\n\tthrow new TypeError(`Unable to resolve body.`);\n}\n","import { EventEmitter } from 'node:events';\nimport type Collection from '@discordjs/collection';\nimport type { request, Dispatcher } from 'undici';\nimport { CDN } from './CDN';\nimport {\n\tHandlerRequestData,\n\tInternalRequest,\n\tRequestData,\n\tRequestManager,\n\tRequestMethod,\n\tRouteLike,\n} from './RequestManager';\nimport type { HashData } from './RequestManager';\nimport type { IHandler } from './handlers/IHandler';\nimport { DefaultRestOptions, RESTEvents } from './utils/constants';\nimport { parseResponse } from './utils/utils';\n\n/**\n * Options to be passed when creating the REST instance\n */\nexport interface RESTOptions {\n\t/**\n\t * The agent to set globally\n\t */\n\tagent: Dispatcher;\n\t/**\n\t * The base api path, without version\n\t * @default 'https://discord.com/api'\n\t */\n\tapi: string;\n\t/**\n\t * The authorization prefix to use for requests, useful if you want to use\n\t * bearer tokens\n\t * @default 'Bot'\n\t */\n\tauthPrefix: 'Bot' | 'Bearer';\n\t/**\n\t * The cdn path\n\t * @default 'https://cdn.discordapp.com'\n\t */\n\tcdn: string;\n\t/**\n\t * Additional headers to send for all API requests\n\t * @default {}\n\t */\n\theaders: Record<string, string>;\n\t/**\n\t * The number of invalid REST requests (those that return 401, 403, or 429) in a 10 minute window between emitted warnings (0 for no warnings).\n\t * That is, if set to 500, warnings will be emitted at invalid request number 500, 1000, 1500, and so on.\n\t * @default 0\n\t */\n\tinvalidRequestWarningInterval: number;\n\t/**\n\t * How many requests to allow sending per second (Infinity for unlimited, 50 for the standard global limit used by Discord)\n\t * @default 50\n\t */\n\tglobalRequestsPerSecond: number;\n\t/**\n\t * The extra offset to add to rate limits in milliseconds\n\t * @default 50\n\t */\n\toffset: number;\n\t/**\n\t * Determines how rate limiting and pre-emptive throttling should be handled.\n\t * When an array of strings, each element is treated as a prefix for the request route\n\t * (e.g. `/channels` to match any route starting with `/channels` such as `/channels/:id/messages`)\n\t * for which to throw {@link RateLimitError}s. All other request routes will be queued normally\n\t * @default null\n\t */\n\trejectOnRateLimit: string[] | RateLimitQueueFilter | null;\n\t/**\n\t * The number of retries for errors with the 500 code, or errors\n\t * that timeout\n\t * @default 3\n\t */\n\tretries: number;\n\t/**\n\t * The time to wait in milliseconds before a request is aborted\n\t * @default 15_000\n\t */\n\ttimeout: number;\n\t/**\n\t * Extra information to add to the user agent\n\t * @default `Node.js ${process.version}`\n\t */\n\tuserAgentAppendix: string;\n\t/**\n\t * The version of the API to use\n\t * @default '10'\n\t */\n\tversion: string;\n\t/**\n\t * The amount of time in milliseconds that passes between each hash sweep. (defaults to 4h)\n\t * @default 14_400_000\n\t */\n\thashSweepInterval: number;\n\t/**\n\t * The maximum amount of time a hash can exist in milliseconds without being hit with a request (defaults to 24h)\n\t * @default 86_400_000\n\t */\n\thashLifetime: number;\n\t/**\n\t * The amount of time in milliseconds that passes between each hash sweep. (defaults to 1h)\n\t * @default 3_600_000\n\t */\n\thandlerSweepInterval: number;\n}\n\n/**\n * Data emitted on `RESTEvents.RateLimited`\n */\nexport interface RateLimitData {\n\t/**\n\t * The time, in milliseconds, until the request-lock is reset\n\t */\n\ttimeToReset: number;\n\t/**\n\t * The amount of requests we can perform before locking requests\n\t */\n\tlimit: number;\n\t/**\n\t * The HTTP method being performed\n\t */\n\tmethod: string;\n\t/**\n\t * The bucket hash for this request\n\t */\n\thash: string;\n\t/**\n\t * The full URL for this request\n\t */\n\turl: string;\n\t/**\n\t * The route being hit in this request\n\t */\n\troute: string;\n\t/**\n\t * The major parameter of the route\n\t *\n\t * For example, in `/channels/x`, this will be `x`.\n\t * If there is no major parameter (e.g: `/bot/gateway`) this will be `global`.\n\t */\n\tmajorParameter: string;\n\t/**\n\t * Whether the rate limit that was reached was the global limit\n\t */\n\tglobal: boolean;\n}\n\n/**\n * A function that determines whether the rate limit hit should throw an Error\n */\nexport type RateLimitQueueFilter = (rateLimitData: RateLimitData) => boolean | Promise<boolean>;\n\nexport interface APIRequest {\n\t/**\n\t * The HTTP method used in this request\n\t */\n\tmethod: string;\n\t/**\n\t * The full path used to make the request\n\t */\n\tpath: RouteLike;\n\t/**\n\t * The API route identifying the ratelimit for this request\n\t */\n\troute: string;\n\t/**\n\t * Additional HTTP options for this request\n\t */\n\toptions: RequestOptions;\n\t/**\n\t * The data that was used to form the body of this request\n\t */\n\tdata: HandlerRequestData;\n\t/**\n\t * The number of times this request has been attempted\n\t */\n\tretries: number;\n}\n\nexport interface InvalidRequestWarningData {\n\t/**\n\t * Number of invalid requests that have been made in the window\n\t */\n\tcount: number;\n\t/**\n\t * Time in milliseconds remaining before the count resets\n\t */\n\tremainingTime: number;\n}\n\nexport interface RestEvents {\n\tinvalidRequestWarning: [invalidRequestInfo: InvalidRequestWarningData];\n\trestDebug: [info: string];\n\trateLimited: [rateLimitInfo: RateLimitData];\n\tresponse: [request: APIRequest, response: Dispatcher.ResponseData];\n\tnewListener: [name: string, listener: (...args: any) => void];\n\tremoveListener: [name: string, listener: (...args: any) => void];\n\thashSweep: [sweptHashes: Collection<string, HashData>];\n\thandlerSweep: [sweptHandlers: Collection<string, IHandler>];\n}\n\nexport interface REST {\n\ton: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);\n\n\tonce: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);\n\n\temit: (<K extends keyof RestEvents>(event: K, ...args: RestEvents[K]) => boolean) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, ...args: any[]) => boolean);\n\n\toff: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);\n\n\tremoveAllListeners: (<K extends keyof RestEvents>(event?: K) => this) &\n\t\t(<S extends string | symbol>(event?: Exclude<S, keyof RestEvents>) => this);\n}\n\nexport type RequestOptions = Exclude<Parameters<typeof request>[1], undefined>;\n\nexport class REST extends EventEmitter {\n\tpublic readonly cdn: CDN;\n\tpublic readonly requestManager: RequestManager;\n\n\tpublic constructor(options: Partial<RESTOptions> = {}) {\n\t\tsuper();\n\t\tthis.cdn = new CDN(options.cdn ?? DefaultRestOptions.cdn);\n\t\tthis.requestManager = new RequestManager(options)\n\t\t\t.on(RESTEvents.Debug, this.emit.bind(this, RESTEvents.Debug))\n\t\t\t.on(RESTEvents.RateLimited, this.emit.bind(this, RESTEvents.RateLimited))\n\t\t\t.on(RESTEvents.InvalidRequestWarning, this.emit.bind(this, RESTEvents.InvalidRequestWarning))\n\t\t\t.on(RESTEvents.HashSweep, this.emit.bind(this, RESTEvents.HashSweep));\n\n\t\tthis.on('newListener', (name, listener) => {\n\t\t\tif (name === RESTEvents.Response) this.requestManager.on(name, listener);\n\t\t});\n\t\tthis.on('removeListener', (name, listener) => {\n\t\t\tif (name === RESTEvents.Response) this.requestManager.off(name, listener);\n\t\t});\n\t}\n\n\t/**\n\t * Gets the agent set for this instance\n\t */\n\tpublic getAgent() {\n\t\treturn this.requestManager.agent;\n\t}\n\n\t/**\n\t * Sets the default agent to use for requests performed by this instance\n\t * @param agent Sets the agent to use\n\t */\n\tpublic setAgent(agent: Dispatcher) {\n\t\tthis.requestManager.setAgent(agent);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the authorization token that should be used for requests\n\t * @param token The authorization token to use\n\t */\n\tpublic setToken(token: string) {\n\t\tthis.requestManager.setToken(token);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Runs a get request from the api\n\t * @param fullRoute The full route to query\n\t * @param options Optional request options\n\t */\n\tpublic get(fullRoute: RouteLike, options: RequestData = {}) {\n\t\treturn this.request({ ...options, fullRoute, method: RequestMethod.Get });\n\t}\n\n\t/**\n\t * Runs a delete request from the api\n\t * @param fullRoute The full route to query\n\t * @param options Optional request options\n\t */\n\tpublic delete(fullRoute: RouteLike, options: RequestData = {}) {\n\t\treturn this.request({ ...options, fullRoute, method: RequestMethod.Delete });\n\t}\n\n\t/**\n\t * Runs a post request from the api\n\t * @param fullRoute The full route to query\n\t * @param options Optional request options\n\t */\n\tpublic post(fullRoute: RouteLike, options: RequestData = {}) {\n\t\treturn this.request({ ...options, fullRoute, method: RequestMethod.Post });\n\t}\n\n\t/**\n\t * Runs a put request from the api\n\t * @param fullRoute The full route to query\n\t * @param options Optional request options\n\t */\n\tpublic put(fullRoute: RouteLike, options: RequestData = {}) {\n\t\treturn this.request({ ...options, fullRoute, method: RequestMethod.Put });\n\t}\n\n\t/**\n\t * Runs a patch request from the api\n\t * @param fullRoute The full route to query\n\t * @param options Optional request options\n\t */\n\tpublic patch(fullRoute: RouteLike, options: RequestData = {}) {\n\t\treturn this.request({ ...options, fullRoute, method: RequestMethod.Patch });\n\t}\n\n\t/**\n\t * Runs a request from the api\n\t * @param options Request options\n\t */\n\tpublic async request(options: InternalRequest) {\n\t\tconst response = await this.raw(options);\n\t\treturn parseResponse(response);\n\t}\n\n\t/**\n\t * Runs a request from the API, yielding the raw Response object\n\t * @param options Request options\n\t */\n\tpublic raw(options: InternalRequest) {\n\t\treturn this.requestManager.queueRequest(options);\n\t}\n}\n"],"mappings":"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","names":[]}